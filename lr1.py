import numpy as np
from numpy.linalg import linalg


def method(A, A_inv, i, x, n):
    l = np.dot(A_inv, x)  # находим некоторый вектор l. Он получается перемножением обратной матрицы А и нашего столбца x
    li = l[i]  # запоминаем в этом векторе i-ый элемент

    if l[i] == 0:  # если этот элемент равен 0, то наша матрица B будет необратимой и всё, конец
        print("False")
        return

    print("True")  # инае обратима, ищем обратную
    l[i] = -1  # получаем другой вектор(2). Он равен нашему вектору l, но на i-ой позиции ставится -1. Для простоты не заводил новый вектор просто
    l_ = [(-1 / li) * x for x in l]  # затем получаем ещё один вектор(3). Он получается умножением вектора(2) на коэффициент -1/li, где li-то, что мы вон там запоминали
    # print(l_)

    Q = np.eye(n)  # теперь берём единичную матрицу
    for j in range(0, n):  # заменяем в ней i-ый стобец на наш вектор (3)
        Q[j][i] = l_[j]
    # print(Q)

    ans = np.dot(Q,
                 A_inv)  # находим обратную матрицу для матрицы B. Для этого просто перемножаем вон ту единичную матрицу с заменой и обратную для матрицы А
    print(ans)

    # Конец. Дальше просто проверка, что правильно получилось
    for j in range(0, n):
        A[j][i] = x[j]

    print(np.dot(ans, A))


def main():
    n = 3
    A = [[1, 0, 5], [2, 1, 6], [3, 4, 0]]  # дана вот такая матрица
    x = [2, 2, 2]  # собственно столбец x
    i = 1  # номер столбца, который в матрице будет заменён на данный нам столбец x
    A_inv = linalg.inv(A)  # Дана ещё матрица, обратная матрице А. Для простоты я её так получал, а не вбивал

    # Задача следующая
    # Пусть мы в матрице А заменили i-ый столбец на столбец x. Обзовём полученную матрицу B
    # Нужно ответить на 2 вопроса:
    # 1. Является ли эта матрица B обратимой(то есть есть ли для неё обратная я так понимаю)
    # 2. Если обратима, то найти обратную

    method(A, A_inv, i, x, n)  # собственно сам метод


if __name__ == '__main__':
    main()
